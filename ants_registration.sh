#!/bin/sh
#

# Orger Lab, 2017
# ANTs whole brain registration bash script
#
# usage: 
#     antsRunRegistration reference moving antsCall
#
#
# HARDCODED USER OPTIONS, ADJUST TO NEED
# -> ANTs_path
#   	Path to ANTs binaries
# -> thread_number
#   	Controls multi-threading. Set to the number of physical
#   	cores in the computer
# Updated 2019-2020.
# - Better/more verbose arguments
# - Usage of masks
# - Automatic transformation of Nth channels
#  - First channel image name must end in _01.[nrrd,nii.gz,tif] unless '-c' flag is used
#  - Nth channel image name must end in _0N.[nrrd,nii.gz,tif]


function Usage {
    cat <<USAGE

Usage:

`basename $0` -f [Template/Fixed Image] -m [Moving Image] -a ANTsCallFile <other options>

Compulsory arguments:

-f: File name (including file type) of the template (fixed) image to be used as the 
	target space for the registration.

-m: File name (including file type) of the moving image.

-a: antsCall file to used for the registration

-------------------------------------------------------

Optional arguments:

-d: Dry run. Outputs the full file names of the output images, but does not run a 
	registration.
	
-s: This controls the transformation of the various channels.
	0: don't run any transformations.
	1: Transform only the first channel/counterstain channel (often tERK).
	2: (Default) Transform all available channels that match the naming pattern of the 
	first channel.	

-h: print the Usage message for `basename $0`

-B: Set the bit depth of the transformed images to 16 bits.
	0: Use the native 32bit output of the ANTs transformation.
	1: (Default) Convert to 16bit output images.

-x: A single mask file to be passed to the registration. For now, this assumes
	that the mask will be applied to the fixed image. The mask should be an 8bit binary 
	mask with 1s where the registration should be applied, and 0s where it should be 
	excluded. The masking step does not seem to apply to the initial transformation step,
	so be careful when using it.

-p: The path to the ANTs binaries. Default is '/usr/bin/'.

-b: The bridging warp file to be used.

-w: A warp file that was previously generated by ANTs/ITK. This will be used to transform
	and images passed along with this. The file should be in '.nii.gz' format. Must be 
	passed with the -r option. **Note that the file stem for the warp must match the filestem
	for the moving image; arbitrary file names cannot currently be used.**
	
-r: A rigid initial alignment file previously generated with ANTs/ITK. This will be used to 
	transform and images passed along with this. The file should be in '.mat' format. 
	Must be passed with the -w option.

-A: The atlas template that is being bridged to. If '-b' is not set, this does nothing.

-T: Thread number. Set to the number of physical cores in the computer. On the cluster
	this could be 12. On a personal laptop this is likely to be 4.
	
USAGE
    exit 1
}

stripEndings(){
	localEnding=`basename $1`
	if [[ $localEnding == *.gz ]] || [[ $localEnding == *.tar ]]; then
		myName=`echo $localEnding | sed -E 's/.gz|.tar//'`
		stripEndings $myName
		return 0
	fi
	myName=`echo $localEnding | sed 's/\.[[:alnum:]]*$//'`
	echo $myName
}

# some sensible default values
thread_number=3
dryRun=0
ANTs_path="/usr/bin/"
bridging=0
mask=""
single=2
outputAs16=1
regChannel=01

transformationArray=()

while getopts ":hdf:A:m:x:a:p:t:b:w:r:s:B:c:" OPT; do
	case $OPT in
		h)
			Usage >&2
			exit 0
		;;
		f)
			fixed=$OPTARG
			if [[ ! -s $fixed ]] ; then echo "No reference image $fixed"  ; exit ; fi
		;;
		A)
			atlas=$OPTARG
		;;
		m)
			moving=$OPTARG
			if [[ ! -s $moving ]] ; then echo "No moving image $moving" ; exit ; fi
		;;
		x)
			mask=$OPTARG
		;;
		a)
			antsCallFile=$OPTARG
			if [[ -z $antsCallFile ]] ; then echo "No antsCall $antsCallFile" ; exit; fi
			if [[ ! -f $antsCallFile ]] ; then
			  antsCallFile=$antsCallFile.antsCall
			  if [[ ! -f $antsCallFile ]] ; then
			    echo "ANTs call file -a ${antsCallFile} was not found"
			    exit
			  fi
			fi
		;;
		p)
			ANTs_path=$OPTARG
		;;
		t)
			thread_number=$OPTARG
		;;
		d)
			dryRun=1
		;;
		b)
			bridging_warp=$OPTARG
			bridging=1
		;;
		w)
			pre_existing_warp=$OPTARG
		;;
		r)
			pre_existing_rigid=$OPTARG
		;;
		s)
			single=$OPTARG
			if [ $single -gt 2 ] ; then
				echo "-s is outside of range"
				echo "Please choose from 0, 1, or 2"
				echo use `basename $0` -h to see a list of valid inputs
		;;
		B)
			outputAs16=$OPTARG
		;;
		c)
			regChannel=$OPTARG
		;;
		\?)
			echo "#########################################"
			echo "    -${OPTARG} is not a valid input!"
			echo "#########################################"
			echo
			echo use `basename $0` -h to see a list of valid inputs
			echo
			exit 0
		;;
	esac
done
if [[ $OPTIND -eq 1 ]]; then
	echo
	echo "##########################" 
	echo "# No options were passed #"
	echo "##########################"
	echo
	Usage >&2
	exit 0
fi



########################################################################
########################################################################
# Set ANTs path
export ANTS_PATH=${ANTs_path}
# Set multi-threading
export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=$thread_number

# cd "/Users/aostrov/projects/OrgerLab/b2bdb/files_registration"
# echo changed directory to `pwd`

if [[ $dryRun -gt 0 ]] ; then
	echo This is a dry run
	echo
else
	mkdir -p registration
fi



# Name preparation
# nm1=`basename ${fixed} | cut -d '.' -f 1`
# nm2=`basename ${moving} | cut -d '.' -f 1`
nm1=`stripEndings ${fixed}`
nm2=`stripEndings ${moving}`
semanticChannelPrimary=`stripEndings ${nm2} | sed -E 's/.*_([[:alnum:]]*$)/\1/'`

nm2=`echo ${nm2} | sed 's/_[[:alnum:]]*$//'`
echo $nm2

# Output filename and path
output=${nm1}_fixed_${nm2%_${regChannel}}_moving_$antsCallFile

if [[ -s registration/${output}_${semanticChannelPrimary}.nii.gz ]] ; then
	# first output already exists!
fi

if [[ -s ${atlas} ]] ; then
	bridging_output=`stripEndings ${atlas}`_via_${output}
fi


# Generate a registration or move existing registration files to
# the expected location
if [[ -z ${pre_existing_rigid} ]] && [[ -z ${pre_existing_warp} ]] ; then
	echo "No pre-existing registrations"
	echo "Let's create a new registration"
	
	if [[ $dryRun -gt 0 ]] ; then
		echo output file: ${output}_${regChannel}.nii.gz
	else
		# Call antsRegistration
		source $antsCallFile
	fi
elif [[ -z ${pre_existing_rigid} ]] || [[ -z ${pre_existing_warp} ]] ; then
	echo "You called for one but not both of:"
	echo "-w: a pre-existing warp .nii.gz"
	echo "-r: a pre-existing rigid .mat"
	echo "Please pass both next time!"
	exit 
else
	if [[ -s ${pre_existing_rigid} ]] && [[ -s ${pre_existing_warp} ]] ; then
		cp ${pre_existing_rigid} ${pre_existing_warp} registration/
	else
		echo "There exists one but not both of these files in the path:"
		echo "a pre-existing warp .nii.gz"
		echo "a pre-existing affine .mat"
		echo "Please pass both next time!"
		exit 
	fi
	
fi


if [ $bridging -eq 1 ] ; then
	if [[ -s ${atlas} ]] && [[ -s ${bridging_warp} ]] ; then
		# generate compound filename
		# a_name=`basename ${atlas} | cut -d '.' -f 1`
		a_name=`stripEndings ${atlas}`
		nm1="${a_name}_via_${nm1}"
		cp ${atlas} ${bridging_warp} registration/
	else
		echo "You passed one but not both of:"
		echo "an atlas"
		echo "a bridging warp"
		echo "Please pass both next time!"
		exit 99
	fi
fi

if [ $single -eq 2 ] ; then
	range=(`ls ${nm2}*`)
elif [ $single -eq 1 ] ; then
	range=($moving)
else
	echo "You have chosen not to transform anything."
	echo "Exiting"
	exit
fi

for i in ${range[@]}; do
	echo $i
	nthChannelIn=$i
	semanticChannel=`stripEndings ${i} | sed -E 's/.*_([[:alnum:]]*$)/\1/'`
	nthChannelOut=${nm1}_fixed_${nm2}_moving_${antsCallFile}_${semanticChannel}.nii.gz
	
	if [[ ! -s registration/$nthChannelOut ]] ; then
		
		echo ""
		echo "Transforming ${nthChannelOut}"
		echo ""
	
		if [[ $dryRun -gt 0 ]] ; then
			echo nthChannelIn: $nthChannelIn
			echo nthChannelOut: $nthChannelOut
		else
			source antsTransformation.sh		
		fi
		
	else
		echo ""
		echo "${nthChannelOut} already exists."
		echo "Skipping"
		echo ""
	fi
done

