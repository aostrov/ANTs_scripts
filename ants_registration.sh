#!/bin/sh
#

# Orger Lab, 2017
# ANTs whole brain registration bash script
#
# usage: 
#     antsRunRegistration reference moving antsCall
#
#
# HARDCODED USER OPTIONS, ADJUST TO NEED
# -> ANTs_path
#   	Path to ANTs binaries
# -> thread_number
#   	Controls multi-threading. Set to the number of physical
#   	cores in the computer
# Updated 2019-2020.
# - Better/more verbose arguments
# - Usage of masks
# - Automatic transformation of Nth channels
#  - First channel image name must end in _01.[nrrd,nii.gz,tif]
#  - Nth channel image name must end in _0N.[nrrd,nii.gz,tif]


function Usage {
    cat <<USAGE

Usage:

`basename $0` -f [Template/Fixed Image] -m [Moving Image] -a ANTsCallFile <other options>

Compulsory arguments:

-f: File name (including file type) of the template (fixed) image to be used as the 
	target space for the registration.

-m: File name (including file type) of the moving image.

-a: antsCall file to used for the registration

-------------------------------------------------------

Optional arguments:

-d: Dry run. Outputs the full file names of the output images, but does not run a 
	registration.
	
-s: This controls the transformation of the various channels.
	0: don't run any transformations.
	1: Transform only the first channel/counterstain channel (often tERK).
	2: (Default) Transform all available channels that match the naming pattern of the 
	first channel.	

-h: print the Usage message for `basename $0`

-B: Set the bit depth of the transformed images to 16 bits.
	0: Use the native 32bit output of the ANTs transformation.
	1: (Default) Convert to 16bit output images.

-x: A single mask file to be passed to the registration. For now, this assumes
	that the mask will be applied to the fixed image. The mask should be an 8bit binary 
	mask with 1s where the registration should be applied, and 0s where it should be 
	excluded. The masking step does not seem to apply to the initial transformation step,
	so be careful when using it.

-p: The path to the ANTs binaries. Default is '/usr/bin/'.

-b: The bridging warp file to be used.

-w: A warp file that was previously generated by ANTs/ITK. This will be used to transform
	and images passed along with this. The file should be in '.nii.gz' format. Must be 
	passed with the -r option.
	
-r: A rigid initial alignment file previously generated with ANTs/ITK. This will be used to 
	transform and images passed along with this. The file should be in '.mat' format. 
	Must be passed with the -w option.

-A: The atlas template that is being bridged to. If '-b' is not set, this does nothing.

-t: Thread number. Set to the number of physical cores in the computer. On the cluster
	this could be 12. On a personal laptop this is likely to be 4.

USAGE
    exit 1
}

# some sensible default values
thread_number=3
dryRun=0
ANTs_path="/usr/bin/"
bridging=0
mask=""
single=2
outputAs16=1
# pre_existing_rigid=NULL
# pre_existing_warp=NULL
#
while getopts ":hdf:A:m:x:a:p:t:b:w:r:s:B:" OPT; do
	case $OPT in
		h)
			Usage >&2
			exit 0
		;;
		f)
			fixed=$OPTARG
		;;
		A)
			atlas=$OPTARG
		;;
		m)
			moving=$OPTARG
		;;
		x)
			mask=$OPTARG
		;;
		a)
			antsCallFile=$OPTARG
		;;
		p)
			ANTs_path=$OPTARG
		;;
		t)
			thread_number=$OPTARG
		;;
		d)
			dryRun=1
		;;
		b)
			bridging_warp=$OPTARG
			bridging=1
		;;
		w)
			pre_existing_warp=$OPTARG
		;;
		r)
			pre_existing_rigid=$OPTARG
		;;
		s)
			single=$OPTARG
		;;
		B)
			outputAs16=$OPTARG
		;;
		\?)
			echo "#########################################"
			echo "    -${OPTARG} is not a valid input!"
			echo "#########################################"
			echo
			echo use `basename $0` -h to see a list of valid inputs
			echo
			exit 0
		;;
	esac
done
if [[ $OPTIND -eq 1 ]]; then
	echo
	echo "##########################" 
	echo "# No options were passed #"
	echo "##########################"
	echo
	Usage >&2
	exit 0
fi



########################################################################
########################################################################
# Set ANTs path
export ANTS_PATH=${ANTs_path}
# Set multi-threading
export ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=$thread_number

# cd "/Users/aostrov/projects/OrgerLab/b2bdb/files_registration"
# echo changed directory to `pwd`

if [[ $dryRun -gt 0 ]] ; then
	echo This is a dry run
	echo
fi
# Set filenames variables
# fixed=$1 ; moving=$2; mask=$4
#
# # Input check
# if [[ $dryRun -gt 0 ]] ; then
# 	antsCallFile=$3
# else
if [[ ! -s $fixed ]] ; then echo "No reference image $fixed"  ; exit ; fi
if [[ ! -s $moving ]] ; then echo "No moving image $moving" ; exit ; fi
if [[ -z $antsCallFile ]] ; then echo "No antsCall $antsCallFile" ; exit; fi
if [[ ! -f $antsCallFile ]] ; then
  antsCallFile=$antsCallFile.antsCall
  if [[ ! -f $antsCallFile ]] ; then
    echo "ANTs call file -a ${antsCallFile} was not found"
    exit
  fi
fi

mkdir -p registration

# Name preparation
nm1=`basename ${fixed} | cut -d '.' -f 1`
nm2=`basename ${moving} | cut -d '.' -f 1`

# Output filename and path
output=${nm1}_fixed_${nm2%_01}_moving_$antsCallFile

# Generate a registration or move existing registration files to
# the expected location
if [[ -z ${pre_existing_rigid} ]] &&[[ -z ${pre_existing_warp} ]] ; then
	echo "No pre-existing registrations"
	echo "Let's create a new registration"
	
	if [[ $dryRun -gt 0 ]] ; then
		echo output file: ${output}_01.nii.gz
	else
		# Call antsRegistration
		source $antsCallFile
	fi
elif [[ -z ${pre_existing_rigid} ]] || [[ -z ${pre_existing_warp} ]] ; then
	echo "You called for one but not both of:"
	echo "-w: a pre-existing warp .nii.gz"
	echo "-r: a pre-existing rigid .mat"
	echo "Please pass both next time!"
	exit 99
else
	if [[ -s ${pre_existing_rigid} ]] && [[ -s ${pre_existing_warp} ]] ; then
		mv ${pre_existing_rigid} ${pre_existing_warp} registration/
	else
		echo "There exists one but not both of these files in the path:"
		echo "a pre-existing warp .nii.gz"
		echo "a pre-existing affine .mat"
		echo "Please pass both next time!"
		exit 99
	fi
	
fi


if [ $bridging -eq 1 ] ; then
	if [[ -s ${atlas} ]] && [[ -s ${bridging_warp} ]] ; then
		# generate compound filename
		a_name=`basename ${atlas} | cut -d '.' -f 1`
		nm1="${a_name}_via_${nm1}"
		mv ${atlas} ${bridging_warp} registration/
	else
		echo "You passed one but not both of:"
		echo "an atlas"
		echo "a bridging warp"
		echo "Please pass both next time!"
		exit 99
	fi
fi

if [ $single -eq 2 ] ; then
	# In the future it might be better to just list
	# all of the files, rather than counting them.
	# This would allow for more than 9 channels to
	# be transformed, but would probably complicate
	# the logic a bit.
	range=`ls ${nm2%_01}_* | wc -l`
elif [ $single -eq 1 ] ; then
	range=1
else
	echo "You have chosen not to transform anything."
	echo "Exiting"
	exit
fi

for i in $(seq 1 $range); do
	nthChannelIn=${nm2%_01}_0${i}.`basename ${moving##*.}`
	nthChannelOut=${nm1}_fixed_${nm2%_01}_moving_${antsCallFile}_0${i}.nii.gz
	if [[ $dryRun -gt 0 ]] ; then
		echo nthChannelIn: $nthChannelIn
		echo nthChannelOut: $nthChannelOut
	else
		source antsTransformation.sh
	fi
done

